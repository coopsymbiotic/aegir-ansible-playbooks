<?php

// phpcs:ignoreFile

/**
 * @file Drupal 9 settings.php file
 *
 * This file was automatically generated by Aegir
 * {{ ansible_managed }}
 *
 * If it is still managed by Aegir, changes to this file may be
 * lost. If it is not managed by aegir, you should remove this header
 * to avoid further confusion.
 */

$databases = [];

$databases['default']['default'] = array(
  'driver' => "mysql",
  'database' => '{{ db_name }}',
  'username' => '{{ db_name }}',
  'password' => '{{ db_passwd }}',
  'host' => '{{ db_host }}',
  'port' => '{{ db_port }}',
  'charset' => 'utf8mb4',
  'collation' => 'utf8mb4_unicode_ci',
);
$db_url['default'] = "mysql://{{ db_name }}:{{ db_passwd }}@{{ db_host }}:{{ db_port }}/{{ db_name }}";

/**
* PHP settings:
*
* To see what PHP settings are possible, including whether they can
* be set at runtime (ie., when ini_set() occurs), read the PHP
* documentation at http://www.php.net/manual/en/ini.php#ini.list
* and take a look at the .htaccess file to see which non-runtime
* settings are used there. Settings defined here should not be
* duplicated there so as to avoid conflict issues.
*/
ini_set('session.gc_probability', 1);
ini_set('session.gc_divisor', 100);
ini_set('session.gc_maxlifetime', 200000);
ini_set('session.cookie_lifetime', 2000000);

/**
* Set the umask so that new directories created by Drupal have the correct permissions
*/
umask(0002);

$settings['file_public_path'] = 'sites/{{ inventory_hostname }}/files';
$settings['file_private_path'] = 'sites/{{ inventory_hostname }}/private/files';
$settings['file_temp_path'] = 'sites/{{ inventory_hostname }}/private/temp';
$config['system.file']['path']['temporary'] = 'sites/{{ inventory_hostname }}/private/temp';
$settings['config_sync_directory'] = 'sites/{{ inventory_hostname }}/private/config/sync';
$settings['hash_salt'] = '{{ (inventory_hostname + aegir_salt) | hash('sha256') }}';
$settings['allow_authorize_operations'] = FALSE;

/**
 * Useless currently, because it is not used in Drupal 8+ anyway.
 * Instead, Drupal 8+ is trying to set the clean URLs mode on the fly,
 * depending on the request, so we should force this by redirecting
 * non-clean to clean URLs on the web server level - Nginx example:
 *
 *   rewrite ^/index.php/(.*)$ $scheme://$host/$1? permanent;
 *
 */
$settings['clean_url'] = 1;

/**
 * Load services definition file.
 */
$settings['container_yamls'][] = __DIR__ . '/services.yml';

/**
 * Trusted Host Settings support.
 */
# $settings['trusted_host_patterns'] = [];

/**
 * Set the Syslog identity to the site name so it's not always "drupal".
 */
$config['syslog.settings']['identity'] = '{{ inventory_hostname }}';

/**
 * If external request was HTTPS but internal request is HTTP, set $_SERVER['HTTPS'] so Drupal detects the right scheme.
 */
if (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && isset($_SERVER['REQUEST_SCHEME'])) {
  if ($_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https' && $_SERVER["REQUEST_SCHEME"] == 'http') {
    $_SERVER['HTTPS'] = 'on';
  }
}

# Extra configuration from modules:

# Additional host wide configuration settings. Useful for safely specifying configuration settings.
if (is_readable('/var/aegir/config/includes/global.inc')) {
  include('/var/aegir/config/includes/global.inc');
}

# Additional platform wide configuration settings.
if (is_readable('{{ site_root }}sites/all/platform.settings.php')) {
  include('{{ site_root }}sites/all/platform.settings.php');
}

# Additional site configuration settings.
if (is_readable('{{ site_path }}/local.settings.php')) {
  include('{{ site_path }}/local.settings.php');
}
